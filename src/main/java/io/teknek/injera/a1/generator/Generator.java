package io.teknek.injera.a1.generator;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

import io.teknek.injera.a1.generated.SampleObj.SelfWriteCallBack;
import io.teknek.injera.a1.model.ComplexType;
import io.teknek.injera.a1.model.Field;
import io.teknek.injera.a1.model.Int32Type;
import io.teknek.injera.a1.model.Int64Type;
import io.teknek.injera.a1.model.StringType;
import io.teknek.injera.a1.model.Struct;
import io.teknek.injera.a1.model.Type;
import io.teknek.injera.a1.model.ListType;
import io.teknek.injera.a1.model.SimpleType;

public class Generator {

  private File targetDirectory;
  public Generator(File targetDirectory){
    this.targetDirectory = targetDirectory;
  }
  
  public void generate(Struct struct, String genPackage, String name, String lang) throws IOException{
    if ("java".equalsIgnoreCase(lang)){
      generateJava(struct, genPackage, name);
    } else {
    throw new RuntimeException("Can not generate "+lang);
    }
  }
  
  private static String capitalize(String s){
    return String.valueOf(s.charAt(0)).toUpperCase() + s.substring(1);
  }
  
  private void generateJava(Struct struct, String genPackage, String name) throws IOException{
    File currentDirectory = targetDirectory;
    if (!targetDirectory.exists()){
      targetDirectory.mkdir();
      System.out.println("created " + targetDirectory);
    }
    String [] parts = genPackage.split("\\.");
    for (String part: parts){
      File child = new File(currentDirectory, part);
      if (!child.exists()){
        child.mkdir();
      }
      currentDirectory = child;
    }
    StringBuilder sb = new StringBuilder();
    sb.append("/* !!Generated by the injera compiler!! \n");
    sb.append(" !!You should not touch this!! */\n");
    sb.append("package " + genPackage + ";" + "\n");
    generateImports(sb);
    sb.append("public class " + capitalize(name) + " {" + "\n");
    sb.append("  private static final int ONE_BYTE_SIZE = -1;" + "\n");
    sb.append("  private static final int TWO_BYTE_SIZE = -2;" + "\n");
    generateFieldEnum(sb, struct);
    sb.append("  private final ByteBuffer injDataBuffer;" + "\n");
    sb.append("  private int maxPosition = 0;" + "\n");
    generateConstructors(sb, struct, name);
    generateSettersAndGetters(sb, struct, name);
    generateReadFunction(sb);
    generateWriteFunction(sb);
    sb.append("}"); // end class
    FileWriter fw = new FileWriter(new File(currentDirectory, capitalize(name)  + ".java"));
    fw.write(sb.toString());
    fw.close();
  } 

  private void generateSettersAndGetters(StringBuilder sb, Struct struct, String name) {
    for (Field field : struct.getFields()){
      if (field.getType() instanceof SimpleType){
        
        String bufferWriteCall = "      injDataBuffer.put(pos, (byte) (me.tag & 0xFF));" + "\n";
        bufferWriteCall += String.format("      injDataBuffer.put%s(pos + 1, x);" + "\n", capitalize(javaPrimitiveOf(field.getType())));
        sb.append("  public void set"+ capitalize(field.getName()) +"(final "+ javaPrimitiveOf(field.getType())+" x){" + "\n");
        sb.append("    Field me =  Field." + field.getName() + ";\n");
        sb.append("    int size = Field." + field.getName() + ".size;" + "\n");
        sb.append("    int pos = locateForWrite(Field."+field.getName()+", size);" + "\n");
        sb.append("    if (pos == -1){" + "\n");
        sb.append("      ////checksizeandallocateifneeded()" + "\n");
        sb.append("      pos = 0;" + "\n");
        sb.append(bufferWriteCall);
        sb.append("      maxPosition = pos + 1 + size;" + "\n");
        sb.append("    } else if (pos == maxPosition) {" + "\n");
        sb.append(bufferWriteCall);
        sb.append("      maxPosition = pos + 1 + size;" + "\n");
        sb.append("    } else if (pos + size == maxPosition){////wrong with variable size" + "\n");
        sb.append(bufferWriteCall);
        sb.append("    } else if (pos + size < maxPosition){ //// wrong with variable size" + "\n");
        sb.append(bufferWriteCall);
        sb.append("    } else {" + "\n");
        sb.append("      throw new RuntimeException(\"Did not conside that\");" + "\n");
        sb.append("    }" + "\n");
        sb.append("  }" + "\n");
        
        
        sb.append("  public "+javaPrimitiveOf(field.getType())+" get"+ capitalize(field.getName()) +"(){" + "\n");
        sb.append("    int pos = locateForRead(Field."+field.getName()+");" + "\n");
        sb.append("    if (pos == -1){" + "\n");
        sb.append("      return 0;" + "\n");
        sb.append("    }" + "\n");
        sb.append(String.format("    return injDataBuffer.get%s(pos + 1);" + "\n", capitalize(javaPrimitiveOf(field.getType()))));
        sb.append("  }" + "\n");
      } else if (field.getType() instanceof ComplexType){
        if (field.getType() instanceof StringType){
          gennerateStringTypeSettersAndGetters(sb, field, name);
        } else if (field.getType() instanceof ListType ){
          generateListTypeSettersAndGetters(sb, field, name);
        } else {
          throw new RuntimeException("what is a "+field);
        }
      }
    }
  }

  private void generateListTypeSettersAndGetters(StringBuilder sb, Field field, String name) {
    ListType t = (ListType) field.getType();
    if (t.getManagedType() instanceof ComplexType){
      throw new RuntimeException("Punting");
    } else if (t.getManagedType() instanceof SimpleType) {
      sb.append(String.format("  public %s [] get%s(){\n", javaPrimitiveOf(t.getManagedType()), capitalize(field.getName())));
      sb.append(String.format("    int pos = locateForRead(Field.%s);\n", field.getName()));
      sb.append("    if (pos == -1){\n");
      sb.append("      return null;\n");
      sb.append("    }\n");
      sb.append(String.format("    %s [] res = new %s [injDataBuffer.get%s(pos + 1)];\n"
              ,javaPrimitiveOf(t.getManagedType()),
              javaPrimitiveOf(t.getManagedType()), 
              capitalize(javaPrimitiveOf(t.getManagedType()))));
      sb.append("    for (int i=0;i<res.length;i++){\n");
      sb.append(String.format("      res[i] = injDataBuffer.get%s((pos + 1 + %s)+ (i * %s));\n", 
              capitalize(javaPrimitiveOf(t.getManagedType())), sizeOf(t.getManagedType()),
              sizeOf(t.getManagedType())));
      sb.append("    }\n");
      sb.append("    return res;\n");
      sb.append("  }\n");
      
      
      String bufferWriteCall =         "      injDataBuffer.put(pos, (byte) (me.tag & 0xFF));" + "\n";
      bufferWriteCall += String.format("      injDataBuffer.putInt(pos + 1, x.length);" + "\n");
      bufferWriteCall += String.format("      injDataBuffer.position(pos + 1 + %s);\n", sizeOf(t.getManagedType()));
      bufferWriteCall += String.format("      for (int i =0;i<x.length;i++){\n");
      bufferWriteCall += String.format("        injDataBuffer.put%s(x[i]);\n", capitalize(javaPrimitiveOf(t.getManagedType())));
      bufferWriteCall += String.format("      }" );
      bufferWriteCall +=               "      injDataBuffer.position(0);\n";
      
      sb.append("  public void set"+ capitalize(field.getName()) +"(final "+ javaPrimitiveOf(t.getManagedType())+" [] x){" + "\n");
      sb.append("    Field me =  Field." + field.getName() + ";\n");
      sb.append("    int size = Field." + field.getName() + ".size;" + "\n");
      sb.append("    int pos = locateForWrite(Field."+field.getName()+", size);" + "\n");
      sb.append("    if (pos == -1){" + "\n");
      sb.append("      ////checksizeandallocateifneeded()" + "\n");
      sb.append("      pos = 0;" + "\n");
      sb.append(bufferWriteCall);
      sb.append("      maxPosition = pos + 1 + 4 + ("+sizeOf(t.getManagedType())+ "* x.length)" + ";\n");
      sb.append("    } else if (pos == maxPosition) {" + "\n");
      sb.append(bufferWriteCall);
      sb.append("      maxPosition = pos + 1 + 4 + ("+sizeOf(t.getManagedType())+ "* x.length)" + ";\n");
      sb.append("    } else if (pos + size == maxPosition){////wrong with variable size" + "\n");
      sb.append(bufferWriteCall);
      sb.append("    } else if (pos + size < maxPosition){ //// wrong with variable size" + "\n");
      sb.append(bufferWriteCall);
      sb.append("    } else {" + "\n");
      sb.append("      throw new RuntimeException(\"Did not conside that\");" + "\n");
      sb.append("    }" + "\n");
      sb.append("  }\n");
     
    }
  }

  private void gennerateStringTypeSettersAndGetters(StringBuilder sb, Field field, String name) {
    sb.append("  public String get"+ capitalize(field.getName())+"(){\n");
    sb.append("    int pos = locateForRead(Field."+ field.getName()+");\n");
    sb.append("    if (pos == -1){\n");
    sb.append("      return \"\";\n");
    sb.append("    }\n"); 
    sb.append("    int size = injDataBuffer.get(pos+1) & 0xFF ;\n");
    sb.append("    byte [] b = new byte [size];\n");
    sb.append("    injDataBuffer.position(pos +2);\n");
    sb.append("    injDataBuffer.get(b, 0 , size);\n");
    sb.append("    injDataBuffer.position(0);\n");
    sb.append("    return new String(b);\n");
    sb.append("  }\n");
  }

  private void generateConstructors(StringBuilder sb, Struct struct, String name) {
    sb.append("  public "+capitalize(name)+ "(){\n");
    sb.append("     injDataBuffer = ByteBuffer.allocate(100);\n");
    sb.append("  }\n");
    
    sb.append("  public "+capitalize(name)+ "(ByteBuffer buffer){\n");
    sb.append("     injDataBuffer = buffer;\n");
    sb.append("  }\n");
  }

  private void generateImports(StringBuilder sb) {
    sb.append("import java.nio.ByteBuffer;\n");
  }

  private void generateFieldEnum(StringBuilder sb, Struct fields) {
    sb.append("  private static enum Field {\n");
    for (Field field : fields.getFields()) {
      
      sb.append("    ").append(field.getName()).append("(").append(field.getPosition()).append(",")
              .append(sizeOf(field.getType())).append(")").append(",").append("\n");
    }
    sb.append("    ;\n");
    sb.append("    Field(int tag, int size){\n");
    sb.append("      this.tag = tag;\n");
    sb.append("      this.size = size;\n");
    sb.append("    }\n");
    sb.append("    int tag;\n");
    sb.append("    int size;\n");
    sb.append("  }\n");

    sb.append("  private static final Field [] fields = new Field[] { null, null, ");
    for (Field field : fields.getFields()) {
      sb.append("Field.").append(field.getName()).append(",");
    }
    sb.append("};\n");
    sb.append("  private Field findFieldForTag(int tag){\n");
    sb.append("    return fields[tag];\n");
    sb.append("  }\n");
  }
  
  private String sizeOf(Type t){
    if (t instanceof Int32Type){
      return "4";
    } else if (t instanceof StringType){
      return "ONE_BYTE_SIZE";
    } else if (t instanceof Int64Type) {
      return "8";
    } else if (t instanceof ComplexType) {
      return "TWO_BYTE_SIZE";
    }
    else throw new RuntimeException("do not know how sizeOf "+t);
  }
  
  private String javaPrimitiveOf(Type t){
    if (t instanceof Int32Type){
      return "int";
    } else if (t instanceof StringType){
      return "String";
    } else if (t instanceof Int64Type) {
      return "long";
    } else throw new RuntimeException("do not know how sizeOf "+t);
  }

  private void generateReadFunction(StringBuilder sb) {
    sb.append("  private int locateForRead(Field searchField){\n");
    sb.append("    if (maxPosition == 0){\n");
    sb.append("      return -1;\n");
    sb.append("    }\n");
    sb.append("    int i = 0;\n");
    sb.append("    while (i < maxPosition){\n");
    sb.append("      int index = injDataBuffer.get(i) & 0xFF;\n");
    sb.append("      if (index == 0){\n");
    sb.append("        return -1;\n");
    sb.append("      }\n");
    sb.append("      if (index == searchField.tag){\n");
    sb.append("        return i;\n");
    sb.append("      }\n");
    sb.append("      if (index > searchField.tag){\n");
    sb.append("        return -1;\n");
    sb.append("      }\n");
    sb.append("      Field f = findFieldForTag(index);\n");
    sb.append("      if (f.size == ONE_BYTE_SIZE){\n");
    sb.append("        int size = injDataBuffer.get(i + 1) & 0xFF ;\n");
    sb.append("        i += size + 1 + 1;\n");
    sb.append("      } else if (f.size == TWO_BYTE_SIZE){\n");
    sb.append("        i += injDataBuffer.getInt(i + 1) + 1 + 4;\n");
    sb.append("      } else {\n");
    sb.append("        i += f.size + 1;\n");
    sb.append("      }\n");
    sb.append("    }\n");
    sb.append("    throw new IllegalArgumentException(\"We done fed up\");\n");
    sb.append("  }\n");
  }
  
  private void generateWriteFunction(StringBuilder sb) {
    sb.append("  private int locateForWrite (Field insertField, int size){\n");
    sb.append("    if (maxPosition == 0){\n");
    sb.append("      return -1;\n");
    sb.append("    } \n");
    sb.append("    int i = 0;\n");
    sb.append("    while (i < maxPosition){\n");
    sb.append("      int tag = injDataBuffer.get(i) & 0xFF;\n");
    sb.append("      if (tag == insertField.tag){\n");
    sb.append("        return i;\n");
    sb.append("      }\n");
    sb.append("      if (tag > insertField.tag){\n");
    sb.append("        int toShift = -1;\n");
    sb.append("        if (insertField.size == ONE_BYTE_SIZE){\n");
    sb.append("          toShift = size + 1;\n");
    sb.append("        } else if (insertField.size == TWO_BYTE_SIZE){\n");
    sb.append("          toShift = size + 1;\n");
    sb.append("        } else {\n");
    sb.append("          toShift= size + 1;\n");
    sb.append("        }\n");
    sb.append("        for (int j = 0; j < toShift; j++) {\n");
    sb.append("          injDataBuffer.put((byte) 0);\n");
    sb.append("        }\n");
    sb.append("        for (int j = maxPosition;j >  i; j--){\n");
    sb.append("          injDataBuffer.put(maxPosition + toShift, \n");
    sb.append("          injDataBuffer.get(maxPosition));\n");
    sb.append("        }\n");
    sb.append("        maxPosition += toShift;\n");
    sb.append("        return i;\n");
    sb.append("      }\n");
    sb.append("      Field iterateField = findFieldForTag(tag);\n");
    sb.append("      if (iterateField.size == -1){\n");
    sb.append("        int objectSize = injDataBuffer.get(i+1) & 0xFF;\n");
    sb.append("        i += objectSize + 2;\n");
    sb.append("      } else {\n");
    sb.append("        i += iterateField.size + 1;\n");
    sb.append("      }\n");
    sb.append("    }\n");
    sb.append("    return i;\n");
    sb.append("  }\n");
  }
}
